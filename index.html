<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<title>PronÃ³stico NMME â€“ Lluvia acumulada (MÃ©xico)</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>

<style>
html, body { margin:0; padding:0; height:100%; font-family: Arial, sans-serif; }
#map { position:absolute; top:80px; bottom:0; left:0; right:0; z-index:1; }

/* ================= HEADER ================= */
#site-header{
  position: fixed; top: 0; left: 0; right: 0; height: 80px;
  background: #ffffff; display: flex; justify-content: space-between; align-items: center;
  padding: 0 28px; box-shadow: 0 2px 10px rgba(0,0,0,0.15); z-index: 3000;
}
.header-left{ display: flex; align-items: center; gap: 14px; }
.header-left img{ height: 52px; }
.header-text .brand{ font-size: 32px; font-weight: 800; color: #2c6cb0; line-height: 1.1; }
.header-text .tagline{ font-size: 20px; font-weight: 800; color: #2c6cb0; }
.btn-contacto{
  border: 1px solid #2c6cb0; padding: 8px 14px; border-radius: 6px;
  text-decoration: none; color: #2c6cb0; font-size: 13px; transition: all 0.2s ease;
}
.btn-contacto:hover{ background: #2c6cb0; color: white; }

/* ================= MENU PANEL ================= */
#menu-panel{
  position:absolute; top:110px; left:50%; transform:translateX(-50%);
  background:rgba(255,255,255,0.96); padding:14px 18px; border-radius:14px;
  box-shadow:0 6px 20px rgba(0,0,0,0.18); z-index:2000; min-width:360px;
}
.menu-header{ display:flex; align-items:center; justify-content:space-between; gap:10px; }
.menu-title{ font-size:15px; font-weight:800; color:#1f3b5c; margin:0; }
.menu-subtitle{ display:block; font-size:12px; font-weight:500; color:#6b7c93; margin-top:2px; }

#menuToggleBtn{
  display:none;
  border:1px solid #cbd5e1;
  background:white;
  border-radius:10px;
  padding:6px 10px;
  font-size:16px;
  line-height:1;
  cursor:pointer;
}
#menuBody{ margin-top:10px; }
#menuBody.is-collapsed{ display:none; }

.menu-controls{ display:flex; align-items:center; justify-content:space-between; gap:14px; }
.toggle-container{ display:flex; align-items:center; gap:8px; font-size:13px; font-weight:600; color:#333; }
.period-container{ display:flex; align-items:center; gap:6px; }
.period-container label{ font-size:12px; font-weight:600; color:#444; }
.period-container select{ font-size:12px; padding:6px 8px; border-radius:8px; border:1px solid #ccc; background:white; }

/* Toggle switch */
.switch{ position:relative; display:inline-block; width:44px; height:22px; }
.switch input{ opacity:0; width:0; height:0; }
.slider-toggle{
  position:absolute; cursor:pointer; top:0; left:0; right:0; bottom:0;
  background:#ccc; transition:.3s; border-radius:22px;
}
.slider-toggle:before{
  position:absolute; content:""; height:18px; width:18px; left:2px; bottom:2px;
  background:white; transition:.3s; border-radius:50%;
}
.switch input:checked + .slider-toggle{ background:#2c6cb0; }
.switch input:checked + .slider-toggle:before{ transform:translateX(22px); }

/* Hover box */
#hoverBox{
  position:fixed; z-index:2000; background:rgba(255,255,255,0.95);
  padding:6px 8px; border-radius:8px; box-shadow:0 0 6px rgba(0,0,0,0.3);
  font-size:11px; pointer-events:none; display:none;
}

/* Legend */
.legend{
  background:white; padding:10px 10px; font-size:12px; border-radius:10px;
  box-shadow:0 0 15px rgba(0,0,0,0.3);
  min-width: 170px;
}
.legend-header{
  display:flex; align-items:center; justify-content:space-between; gap:8px; margin-bottom:8px;
}
.legend-title{ font-weight:800; color:#1f3b5c; font-size:12px; }
.legend-toggle{
  border:1px solid #cbd5e1; background:white; border-radius:8px;
  padding:4px 8px; font-size:12px; cursor:pointer;
}
.legend-body.is-collapsed{ display:none; }
.legend-row{ display:flex; align-items:center; }
.legend-color-box{ width:16px; height:16px; margin-right:6px; border:1px solid #ccc; border-radius:3px; }

/* Raster nÃ­tido (Leaflet lo dibuja como <img>) */
.leaflet-image-layer { image-rendering: pixelated; image-rendering: crisp-edges; }

/* ================= RESPONSIVE (MÃ“VIL) ================= */
@media (max-width: 600px){
  #site-header{ height: 64px; padding: 0 12px; }
  .header-left img{ height: 42px; }
  .header-text .brand{ font-size: 20px; }
  .header-text .tagline{ font-size: 12px; font-weight: 700; }
  #map{ top:64px; }

  #menu-panel{
    top: 74px;
    left: 10px;
    right: 10px;
    transform: none;
    min-width: unset;
    border-radius: 14px;
    padding: 10px 12px;
  }

  .menu-title{ font-size: 14px; }
  .menu-subtitle{ font-size: 11px; }
  #menuToggleBtn{ display:inline-flex; align-items:center; justify-content:center; }

  .menu-controls{ flex-direction: column; align-items: stretch; gap:10px; }
  .period-container{ justify-content: space-between; }
  .period-container select{ width: 100%; }
}
</style>
</head>

<body>
<header id="site-header">
  <div class="header-left">
    <img src="logo2.jpeg" alt="ClimaproAgro logo">
    <div class="header-text">
      <div class="brand">ClimaproAgro</div>
      <div class="tagline">InformaciÃ³n ClimÃ¡tica para la Agricultura</div>
    </div>
  </div>
  <div class="header-right">
    <a href="https://www.climaproagro.com/contacto" class="btn-contacto">Contacto</a>
  </div>
</header>

<div id="menu-panel">
  <div class="menu-header">
    <div>
      <div class="menu-title">PronÃ³stico NMME â€“ Lluvia acumulada</div>
      <span class="menu-subtitle">MÃ©xico</span>
    </div>
    <button id="menuToggleBtn" type="button" aria-label="Mostrar/Ocultar panel">â˜°</button>
  </div>

  <div id="menuBody">
    <div class="menu-controls">
      <div class="toggle-container">
        <span>Mensual</span>
        <label class="switch">
          <input type="checkbox" id="typeToggle">
          <span class="slider-toggle"></span>
        </label>
        <span>Bimestral</span>
      </div>

      <div class="period-container">
        <label for="periodSelect">Periodo</label>
        <select id="periodSelect"></select>
      </div>
    </div>
  </div>
</div>

<div id="map"></div>
<div id="hoverBox"></div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
/* ================= AJUSTES DE ALINEACIÃ“N =================
  EDGE_FACTOR:
    0.5 = lon/lat son CENTROS de celda (lo normal)
  SHIFT_CELLS:
    -0.5 = mover 1/2 celda al SUR (si el raster estÃ¡ corrido al NORTE)
    -1.0 = mover 1 celda al SUR
    +0.5 = mover 1/2 celda al NORTE (si estuviera corrido al SUR)
*/
const EDGE_FACTOR      = 0.5;
const LAT_SHIFT_CELLS  = 0.0;   // ðŸ‘ˆ tu caso: raster movido al NORTE -> baja al SUR
const LON_SHIFT_CELLS  = 0.0;

/* ================= CONFIG ================= */
let currentData = null;
const VAR_LABEL = "Lluvia acumulada";
const VAR_UNITS = "mm";

let currentType = "mensual";
let steps = [];
let map, rasterOverlay, legend;

const URL_MX_STATES  = "https://raw.githubusercontent.com/strotgen/mexico-leaflet/master/states.geojson";
const URL_MX_COUNTRY = "https://raw.githubusercontent.com/johan/world.geo.json/master/countries/MEX.geo.json";

// Si quieres el borde nacional, pon true
const DRAW_COUNTRY_BORDER = false;
const STATE_LINE_WEIGHT   = 1.0;
const COUNTRY_LINE_WEIGHT = 1.5;

/* ================= UTILS ================= */
function monthNameEs(m){
  return ["Ene","Feb","Mar","Abr","May","Jun","Jul","Ago","Sep","Oct","Nov","Dic"][m-1];
}
function prettyFromName(f){
  let m = f.match(/_(\d{6})_(\d{6})/);
  if (m) return `${monthNameEs(+m[1].slice(4))}â€“${monthNameEs(+m[2].slice(4))} ${m[1].slice(0,4)}`;
  m = f.match(/_(\d{6})/);
  if (m) return `${monthNameEs(+m[1].slice(4))} ${m[1].slice(0,4)}`;
  return f;
}
function normalizeLon(lon){
  // 0â€“360 -> -180â€“180
  return (lon > 180) ? lon - 360 : lon;
}
async function fetchJsonSafe(url){
  const res = await fetch(url, { cache: "force-cache" });
  const txt = await res.text();
  if (!res.ok) throw new Error(`HTTP ${res.status} al descargar: ${url}`);
  const t = txt.trim();
  if (!(t.startsWith("{") || t.startsWith("["))){
    throw new Error(`No parece JSON: ${url}\nInicio: ${t.slice(0,120)}`);
  }
  return JSON.parse(t);
}

/* ================= MAP ================= */
function initMap(){
  map = L.map("map", { zoomControl: true, minZoom: 4, maxZoom: 10 }).setView([23,-102],5);

  L.tileLayer(
    "https://{s}.basemaps.cartocdn.com/light_nolabels/{z}/{x}/{y}{r}.png",
    { attribution: "Â© OpenStreetMap, Â© CARTO" }
  ).addTo(map);

  L.tileLayer(
    "https://{s}.basemaps.cartocdn.com/rastertiles/voyager_nolabels/{z}/{x}/{y}{r}.png",
    { opacity: 0.6 }
  ).addTo(map);

  L.tileLayer(
    "https://{s}.basemaps.cartocdn.com/light_only_labels/{z}/{x}/{y}{r}.png",
    { opacity: 0.9 }
  ).addTo(map);

  L.tileLayer(
    "https://{s}.basemaps.cartocdn.com/rastertiles/voyager_only_labels/{z}/{x}/{y}{r}.png",
    { opacity: 0.15 }
  ).addTo(map);

  // Legend control
  legend = L.control({ position: "bottomright" });
  legend.onAdd = function(){
    const div = L.DomUtil.create("div", "legend");
    div.innerHTML = `
      <div class="legend-header">
        <div class="legend-title">Leyenda</div>
        <button class="legend-toggle" type="button">Ocultar</button>
      </div>
      <div class="legend-body">Cargandoâ€¦</div>
    `;
    L.DomEvent.disableClickPropagation(div);
    L.DomEvent.disableScrollPropagation(div);
    return div;
  };
  legend.addTo(map);

  // Hover: usa vecino mÃ¡s cercano (coincide con el pixel renderizado)
  map.on("mousemove", e => {
    if (!currentData) return;

    const val = valueAtPixelNearest(e.latlng);
    const box = document.getElementById("hoverBox");

    if (val === null){
      box.style.display = "none";
      return;
    }

    box.innerHTML = `
      <b>${VAR_LABEL}</b><br>
      Valor: <b>${val.toFixed(1)} ${VAR_UNITS}</b><br>
      Lat: ${e.latlng.lat.toFixed(2)}Â°<br>
      Lon: ${e.latlng.lng.toFixed(2)}Â°<br>
      Tipo: ${currentType === "mensual" ? "Mensual" : "Bimestral"}
    `;
    box.style.left = (e.originalEvent.pageX + 15) + "px";
    box.style.top  = (e.originalEvent.pageY + 15) + "px";
    box.style.display = "block";
  });

  map.on("mouseout", () => {
    document.getElementById("hoverBox").style.display = "none";
  });
}

/* ================= MÃ©xico (estados + borde opcional + limitar vista) ================= */
let mxStatesLayer = null;
let mxCountryLayer = null;

async function loadMexicoBoundaries(){
  try {
    const [countryGeojson, statesGeojson] = await Promise.all([
      fetchJsonSafe(URL_MX_COUNTRY),
      fetchJsonSafe(URL_MX_STATES)
    ]);

    if (mxStatesLayer) map.removeLayer(mxStatesLayer);
    if (mxCountryLayer) map.removeLayer(mxCountryLayer);

    mxStatesLayer = L.geoJSON(statesGeojson, {
      interactive: false,
      style: { color: "#2b2b2b", weight: STATE_LINE_WEIGHT, opacity: 0.55, fillOpacity: 0 }
    }).addTo(map);

    if (DRAW_COUNTRY_BORDER){
      mxCountryLayer = L.geoJSON(countryGeojson, {
        interactive: false,
        style: { color: "#111111", weight: COUNTRY_LINE_WEIGHT, opacity: 0.9, fillOpacity: 0 }
      }).addTo(map);
    }

    const boundsMx = (mxCountryLayer ? mxCountryLayer.getBounds() : mxStatesLayer.getBounds());
    map.fitBounds(boundsMx.pad(0.03));
    map.setMaxBounds(boundsMx.pad(0.08));
  } catch (err){
    console.error("[Mexico boundaries]", err);
    alert("No pude cargar lÃ­mites de MÃ©xico/estados. Revisa tu conexiÃ³n o las URLs de GeoJSON.");
  }
}

/* ================= Panel colapsable (mÃ³vil) + leyenda colapsable ================= */
function setupCollapsibles(){
  const menuPanel = document.getElementById("menu-panel");
  const menuBody  = document.getElementById("menuBody");
  const menuBtn   = document.getElementById("menuToggleBtn");

  if (menuPanel){
    L.DomEvent.disableClickPropagation(menuPanel);
    L.DomEvent.disableScrollPropagation(menuPanel);
  }

  const isMobile = window.matchMedia && window.matchMedia("(max-width: 600px)").matches;

  if (isMobile){
    menuBody.classList.add("is-collapsed");
    menuBtn.textContent = "â˜°";
  }

  menuBtn.addEventListener("click", () => {
    const collapsed = menuBody.classList.toggle("is-collapsed");
    menuBtn.textContent = collapsed ? "â˜°" : "âœ•";
  });

  const legendEl = document.querySelector(".legend");
  if (!legendEl) return;

  const legendBtn  = legendEl.querySelector(".legend-toggle");
  const legendBody = legendEl.querySelector(".legend-body");

  if (isMobile && legendBody){
    legendBody.classList.add("is-collapsed");
    if (legendBtn) legendBtn.textContent = "Mostrar";
  }

  if (legendBtn && legendBody){
    legendBtn.addEventListener("click", () => {
      const collapsed = legendBody.classList.toggle("is-collapsed");
      legendBtn.textContent = collapsed ? "Mostrar" : "Ocultar";
    });
  }
}

/* ================= COLORS ================= */
const PRATE_LEVELS = [1,30,60,90,120,180,240,360,500,600,700,800,1000];
const PRATE_COLORS = [
  "#ffffff", "#ffffff", "#fee391", "#fec44f", "#addd8e", "#78c679",
  "#41ab5d", "#238443", "#1f78b4", "#225ea8", "#253494", "#54278f", "#7a0177"
];
function hexToRGBA(hex, alpha=255){
  const c = hex.replace("#","");
  return [
    parseInt(c.substring(0,2),16),
    parseInt(c.substring(2,4),16),
    parseInt(c.substring(4,6),16),
    alpha
  ];
}
function getColorPrate(v){
  if (!isFinite(v) || v < 1) return [255,255,255,0];
  for (let i = 0; i < PRATE_LEVELS.length - 1; i++){
    if (v >= PRATE_LEVELS[i] && v < PRATE_LEVELS[i+1]){
      return hexToRGBA(PRATE_COLORS[i+1], 255);
    }
  }
  return hexToRGBA(PRATE_COLORS[PRATE_COLORS.length - 1], 200);
}
function buildLegendHTML(periodLabel){
  let html = `<b>${VAR_LABEL} (${VAR_UNITS})</b><br>`;
  html += `<span style="font-size:11px">${periodLabel}</span><br><br>`;
  const PRATE_LABELS = [
  "&lt; 30", "30 â€“ 60", "60 â€“ 90", "90 â€“ 120",
  "120 â€“ 180", "180 â€“ 240", "240 â€“ 360", "360 â€“ 500",
  "500 â€“ 600", "600 â€“ 700", "700 â€“ 800", "800 â€“ 1000", "> 1000"
  ];

  for (let i = 0; i < PRATE_LEVELS.length - 1; i++){
    const label = (i < PRATE_LABELS.length) ? PRATE_LABELS[i] : `${PRATE_LEVELS[i]} â€“ ${PRATE_LEVELS[i+1]}`;

    html += `
      <div class="legend-row">
        <div class="legend-color-box" style="background:${PRATE_COLORS[i+1]}"></div>
        <span>${label}</span>
      </div>
    `;
  }
  html += `
    <div class="legend-row">
      <div class="legend-color-box" style="background:${PRATE_COLORS[PRATE_COLORS.length-1]}"></div>
      <span>&gt; ${PRATE_LEVELS[PRATE_LEVELS.length-1]}</span>
    </div>
  `;
  return html;
}

/* ================= RASTER (alineado) + HOVER (coherente con pixel) ================= */

function drawRaster(data){
  // Copias locales (NO mutar el JSON)
  let lat = data.grid.lat.slice();                 // [ny]
  let lon = data.grid.lon.map(normalizeLon);       // [nx]
  let z   = data.grid.data;                        // [ny][nx]

  const ny = lat.length;
  const nx = lon.length;

  // 1) Asegurar lon creciente y reordenar Z si hace falta
  let lonIncreasing = true;
  for (let j = 1; j < nx; j++){
    if (!(lon[j] > lon[j-1])) { lonIncreasing = false; break; }
  }
  if (!lonIncreasing){
    const idx = lon.map((v,i)=>[v,i]).sort((a,b)=>a[0]-b[0]).map(p=>p[1]);
    lon = idx.map(i => lon[i]);
    z   = z.map(row => idx.map(j => row[j]));
  }

  // 2) Resoluciones
  const dLat = (ny > 1) ? Math.abs(lat[1] - lat[0]) : 0.5;
  const dLon = (nx > 1) ? Math.abs(lon[1] - lon[0]) : 0.5;

  // 3) Bounds por BORDES (centros Â± EDGE_FACTOR*delta) + shift en celdas
  const latMin = Math.min(...lat), latMax = Math.max(...lat);
  const lonMin = Math.min(...lon), lonMax = Math.max(...lon);

  const latShiftDeg = LAT_SHIFT_CELLS * dLat;
  const lonShiftDeg = LON_SHIFT_CELLS * dLon;

  const bounds = [
    [latMin - dLat*EDGE_FACTOR + latShiftDeg, lonMin - dLon*EDGE_FACTOR + lonShiftDeg],
    [latMax + dLat*EDGE_FACTOR + latShiftDeg, lonMax + dLon*EDGE_FACTOR + lonShiftDeg]
  ];

  // 4) Flip vertical correcto
  const latIncreasing = (ny > 1) ? (lat[1] > lat[0]) : true;

  // 5) Render canvas -> dataURL
  const canvas = document.createElement("canvas");
  canvas.width = nx;
  canvas.height = ny;
  const ctx = canvas.getContext("2d");
  const img = ctx.createImageData(nx, ny);

  // mÃ¡scara: 1 si el pÃ­xel se pintÃ³ (alpha>0)
  const drawn = new Uint8Array(nx * ny);

  for (let i = 0; i < ny; i++){
    for (let j = 0; j < nx; j++){
      const v = z[i][j];
      if (v == null || !isFinite(v)) continue;

      const rgba = getColorPrate(v);
      if (rgba[3] === 0) continue;

      // Leaflet espera â€œnorth on topâ€
      const yPix = latIncreasing ? (ny - 1 - i) : i;

      const kPix = yPix * nx + j; // pixel index
      const k = kPix * 4;         // rgba index

      drawn[kPix] = 1;

      img.data[k]   = rgba[0];
      img.data[k+1] = rgba[1];
      img.data[k+2] = rgba[2];
      img.data[k+3] = rgba[3];
    }
  }

  ctx.putImageData(img, 0, 0);

  if (rasterOverlay) map.removeLayer(rasterOverlay);
  rasterOverlay = L.imageOverlay(canvas.toDataURL(), bounds, {
    opacity: 1.0,
    interactive: false
  }).addTo(map);

  // Guardar render EXACTO para hover coherente
  currentData._render = {
    z,
    nx, ny,
    latIncreasing,
    bounds: rasterOverlay.getBounds(),
    drawn
  };
}

function valueAtPixelNearest(latlng){
  if (!currentData || !currentData._render) return null;

  const R = currentData._render;
  const b = R.bounds;

  // âœ… Usar la proyecciÃ³n del CRS (EPSG:3857)
  const crs = map.options.crs;
  const p   = crs.project(latlng);
  const nw  = crs.project(b.getNorthWest());
  const se  = crs.project(b.getSouthEast());

  const x = (p.x - nw.x) / (se.x - nw.x);
  const y = (nw.y - p.y) / (nw.y - se.y); // top=0, bottom=1

  if (x < 0 || x > 1 || y < 0 || y > 1) return null;

  // Pixel del canvas (top-left)
  const jPix = Math.max(0, Math.min(R.nx - 1, Math.floor(x * R.nx)));
  const iPix = Math.max(0, Math.min(R.ny - 1, Math.floor(y * R.ny)));

  // mÃ¡scara: si no se pintÃ³ ese pixel, no hay hover
  const kPix = iPix * R.nx + jPix;
  if (R.drawn && R.drawn[kPix] === 0) return null;

  // Convertir canvas -> Ã­ndice del grid original (por flip vertical)
  const i = R.latIncreasing ? (R.ny - 1 - iPix) : iPix;
  const j = jPix;

  const v = R.z[i][j];
  return (v == null || !isFinite(v)) ? null : v;
}

  

/* ================= DATA ================= */
function loadManifest(){
  fetch(`${currentType}/auto_manifest.json`)
    .then(r => r.json())
    .then(m => {
      steps = m.files || m;
      const sel = document.getElementById("periodSelect");
      sel.innerHTML = steps.map(f => `<option value="${f}">${prettyFromName(f)}</option>`).join("");
      loadGrid();
    })
    .catch(err => console.error("[manifest]", err));
}

function loadGrid(){
  const sel = document.getElementById("periodSelect");
  if (!sel.value) return;

  fetch(`${currentType}/${sel.value}`)
    .then(r => r.json())
    .then(json => {
      currentData = json;
      drawRaster(json);

      const body = document.querySelector(".legend-body");
      if (body){
        body.innerHTML = buildLegendHTML(
          `${currentType === "mensual" ? "Mensual" : "Bimestral"} â€“ ${prettyFromName(sel.value)}`
        );
      }
    })
    .catch(err => console.error("[grid]", err));
}

/* ================= EVENTS ================= */
document.getElementById("typeToggle").onchange = e =>{
  currentType = e.target.checked ? "bimestral" : "mensual";
  loadManifest();
};
document.getElementById("periodSelect").onchange = loadGrid;

window.onload = ()=>{
  initMap();
  loadManifest();
  loadMexicoBoundaries();
  setupCollapsibles();
};
</script>
</body>
</html>
